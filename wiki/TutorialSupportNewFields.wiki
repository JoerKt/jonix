#summary How to support new types of ONIX fields

= Introduction =

In this tutorial we'll add the `Measure` composite of ONIX, which describes the physical dimensions of a printed book. It has the following generalform:

{{{
<Measure>
	<MeasureTypeCode>01</MeasureTypeCode>
	<Measurement>9.25</Measurement>
	<MeasureUnitCode>in</MeasureUnitCode>
</Measure>
<Measure>
	<MeasureTypeCode>02</MeasureTypeCode>
	<Measurement>6.25</Measurement>
	<MeasureUnitCode>in</MeasureUnitCode>
</Measure>
<Measure>
	<MeasureTypeCode>03</MeasureTypeCode>
	<Measurement>1.2</Measurement>
	<MeasureUnitCode>in</MeasureUnitCode>
</Measure>
}}}

Being an ONIX composite, it repeats the same structure several times, each with its own values.

= Part 1: The Consumer =

The hardest part of supporting a new ONIX composite, is to develop its corresponding `JonixConsumer` - the class that will transform the above XML into an easy-to-use Java class. This transformation, actually, doesn't start with the XML string itself, but with a JAXB-generated Java representation of it. So we're facing a conversion from a very raw Java object into a more specific, Jonix-style object. This is exactly what `JonixConsumer` is all about.

So we start by finding out how JAXB would generate the raw Java objects. Open `ONIX.java`, which is a huge enumerator spanning all supported ONIX packages, and look for the object `Measure`:

{{{
/**
 * An optional and repeatable group of data elements which together identify a measurement and the units in which it is expressed.
 * 
 * @version
 *          2.1.04, April 2011
 * @version
 *          3.0.01, January 2012
 * @links
 *        {@link org.editeur.onix.v21.references.Measure}<br/>
 *        {@link org.editeur.onix.v21.shorts.Measure}<br/>
 *        {@link org.editeur.onix.v30.references.Measure}<br/>
 *        {@link org.editeur.onix.v30.shorts.Measure}<br/>
 */
Measure,
}}}

In its comment, there are links to several JAXB classes, all representing the `Measure` composites (in different versions/forms). For convenience, open the first, `org.editeur.onix.v21.references.Measure`, and look for the juicy parts:

{{{
...
@XmlType(name = "", propOrder = {
    "measureTypeCode",
    "measurement",
    "measureUnitCode"
})
@XmlRootElement(name = "Measure")
public class Measure {

    @XmlElement(name = "MeasureTypeCode", required = true)
    protected MeasureTypeCode measureTypeCode;
    @XmlElement(name = "Measurement", required = true)
    protected Measurement measurement;
    @XmlElement(name = "MeasureUnitCode", required = true)
    protected MeasureUnitCode measureUnitCode;
    ...
}}}

We see that the three items we're interested in (`measureTypeCode`, `measurement` and `measureUnitCode`) are all fields, and each has its own JAXB-generated type. The first, `measureTypeCode` is of type `MeasureTypeCode`, which, if you look at its implementation:
  * has a single property, `value`, stored as a String
  * refers to the code-list 48, as explained at the beginning of the class' comment  
This code-list, like all code-lists, must have a corresponding Jonix enum in the package `org.jonix.codelist`. It can be located by the name and the comment it has. In this case, the Jonix enum from code-list 48 is the class `org.jonix.codelist.MeasureTypes`.

Go ahead and explore the other two types by yourself. You'll see that the third property, `measureUnitCode` is of type `MeasureUnitCode`, which has a `value` property of type `List50`, which in turn has its own `value` property, containing the String that we're after.

This is the kind of information needed to extract data from a raw JAXB object and convert it into a Jonix object. The class that would retain a single `Measure` record in our implementation is going to look like that:

{{{
public class Measure
{
	// we keep the members public and final, to avoid cumbersome getters/setters
	public final MeasureTypes measureType;
	public final double measurement;
	public final MeasureUnits measureUnit;

	public Measure(MeasureTypes measureType, double measurement, MeasureUnits measureUnit)
	{
		this.measureType = measureType;
		this.measurement = measurement;
		this.measureUnit = measureUnit;
	}

	@Override
	public String toString()
	{
		return String.format("Measure %s = %.3f [%s]", measureType.name(), measurement, measureUnit.name());
	}
}
}}}

The composite class, however, is going to be a `List` of such objects. We'll call it `Measures`. It will also have to implement `JonixConsumer` in order to "consume" the `<Measure>` tags during the parsing process. By convention in Jonix, an inner-class syntax is used, as follows:

{{{
public class Measures extends JonixComposite<Measures.Measure>
{
	public static class Measure implements Serializable
	{
		// shown above
	}

	@Override
	public JonixConsumer consume(Object o, Object parent, Object grandParent, JonixResolver resolver)
	{
		// coming up next..
	}
}
}}}

The last thing left to do is to actually participate in the parsing process of an ONIX source and "snatch" the `Measure` tags into our composite class. The reader is encouraged to read the Javadocs pertaining to the parsing process in general and the consumption mechanism in particular (see the Javadocs for the interface `JonixConsumer` to begin with).
In general lines, when the parser reaches a new top-tag (i.e. right below `<Product>`) it asks all the consumers, who "knows" how to consume it. When a consumer says "I do", it well be given an exclusive access to the tag as well as its child tags (NOTE: in `Measure` tag, all the information we need is parsed by JAXB into properties at the parent level, so we don't need to handle sub-tags. This is not the case in more complex composites, such as `Price` and `Series`, whose consumption code you can study). So we need to do the following in the `consume()` method:
  * find out whether the raw Java object in question is a `Measure` tag (remember, it has a different tag-name in the Short form)
  * extract the values of the three properties in such a way that our code will work in all ONIX variants
  * signal to the parser whether or not we have consumed the tag
This is how it's done in Jonix:

{{{
@Override
public JonixConsumer consume(Object o, Object parent, Object grandParent, JonixResolver resolver)
	if (resolver.onixTypeOf(o) == ONIX.Measure)
	{
		String measureTypeCode = (String) JonixUtils.getProperty(o, resolver.onixPropOf(ONIX.MeasureTypeCode), "value");
		String measureUnitCode = (String) JonixUtils.getProperty(o, resolver.onixPropOf(ONIX.MeasureUnitCode), "value", "value");
		String measurementStr = (String) JonixUtils.getProperty(o, resolver.onixPropOf(ONIX.Measurement), "value");

		add(new Measure(MeasureTypes.fromCode(measureTypeCode), Double.valueOf(measurementStr), MeasureUnits.fromCode(measureUnitCode)));
		return this;
	}

	return null;
}
}}}

The first `if` relies on the Jonix framework services. Given a `resolver`, which represents the specific ONIX version of the source, we can translate the object in question (passed as `o`) into an `ONIX` enum (which is shared among all ONIX versions). This enum is then compared to the enum object representing the tag we want to consume - `ONIX.Measure`.

Once we know that `o` represents a `Measure` JAXB-object, we extract the three properties. Again, we use a Jonix framework service called `getProperty(o, properties..)` which, given the object `o`, accesses one of its field (provided by name). If this field value is expected to be another object, a second field name can be passed, and so on. For example, the `measureUnitCode` property value is actually stored in a path which can be described as follows:

`o --> "measureUnitCode" --> "value" --> "value"